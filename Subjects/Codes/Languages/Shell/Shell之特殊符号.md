[[Linux]]
[[Shell]]

tags: #来源/转载 
#资料 

#### \; 分号

连续运行命令语句。

`# ifdown eth0 ; ifup eth0`

#### \| 管道

正则表达式中表示或者 

`# echo "ooooee" |egrep '(oo|ee)'{2}`表示匹配 oooo 或者 eeee 的字符

前面命令的标准输出作为后面命令的标准输入

`# ifconfig|grep eth0`     表示ifconfig查出来的信息然后过滤出`eth0`的这一行

#### \& 号

将命令放到后台执行

`# mysqld\_safe --user=mysql &`        将MySQL放到后台启动

表示标准输出和标准错误输出

`# ifconfig &>/dev/null`   将ifconfig执行得到的结果输出到`/dev/null`里面

#### \&\& 号

前面命令返回值为0才执行后面的命令。暨必须前面的命令语句执行的程序执行成功才可以执行下一条命令。

`# ls && echo "ok" `

#### ||号

前面命令返回值为非0才执行后面的命令

`# lls || echo "ok" `

#### \# 井号

`# `表示注释

`$#` 表示位置参数的个数

`# echo $#` 输出0

`${#变量名} `表示变量的长度

`# a='hello' # echo ${#a}` 输出5

`${#变量名[@]}` 表示数组的个数

`# a=(1 2 3) # echo ${#a[@]}` 3

#### \! 惊叹号

将命令或者条件表达式的返回值取反

`# if ! [ 1<2 ]; then echo 'ok'; else echo 'no'; fi`输出ok

执行历史命令

`# history 1 ls 2 tail test1.txt 3 mysql \-uroot \-p123 4 ls /tmp/ 5 cd /tmp/ [root@localhost ~]# !994 ls /tmp/ account.sql  data.sql  mysql.sock  t1.txt  t2.txt `

vi或者ftp中执行外部shell命令

例如：在vim中，想要执行一条命令，就在末行模式，输入`! 后面加上要执行的命令`

间接应用变量 

例如：`${!a} `---- 间接取b 的值

#### \$ 美元符号

取变量的值

`# a=10 # echo $a` 10

正则表达式表示行尾

`egrep ':$' /etc/inittab` 
`egrep ‘^hello$'  file`

#### \> 大于号

输出重定向

`echo '123' >test.txt` 表示将123 输入到文件test.txt中

条件测试中的大于号

#### \< 小于号

输入重定向

条件测试中的小于号

#### \= 等号

**变量赋值**。注意=左右不能有空格。

例如：设置变量`a=10` 

**条件测试中的等号** 。 例如：`[ a=b ]`判断变量a是否等于b

**数值比较 \=\=** 。 例如：`(( a==20 ))` 判断变量a是否等于20

#### \+ 加号

算术运算中的加号 。 例如：`1+3`

正则表达式中1个或多个前面的字符 。例如：`ab+c` 表示匹配ab和c之间有1个或者多个 字符

#### \>\> 追加输出

**输出重定向追加** 。 例如：`echo "123" >> test.txt` 将123追加到文件test.txt中

#### \<\< 号

here document

例如：

`# passwd <<end > 123 > 123 > end`

更改用户 root 的密码 。

#### \- 减号

算术运算中的减号。例如：`10-2` 

命令的选项 。例如：`ls -l`

上一次工作目录。例如：`cd -`

通配符和正则表达式中表示范围 - 例如：`[a-z]` 

`tar -cvf - /home | tar -xvf - `

表示输出流或输入流

将前面的输出 ，通过管道交给后面的命令，前面的压缩，后面的解压

#### \' \' 单引号

解决变量赋值空格的问题 

例如：`a='1 2'`

阻止shell替换

#### \" \" 双引号 

解决变量赋值空格的问题

例如：`a="1 2"`

阻止shell部分字符替换，对\$、\!等无效

#### \`\` 反引号 

相当于 `$()`

命令行替换

例如：可以设变量`a=$(ls)`

#### \% 百分号

算术运算中的模运算

例如：`echo $((100%10))` 就是100除以10的余数为0

vi中替换操作中表示所有行 （末行模式下，替换所有前面加 `%`）

例如：在末行模式下输入 :`% s/D/d` 表示将文本中的所有的D替换为d

#### \( \) 单圆括号

子shell中执行命令，会继承父shell的变量 

括起数组元素

例如：定义一个数组 `a=(1 2 3 4)`

#### \(\( \)\) 双圆括号 

算术运算

例如：`echo $((10/2)) `结果就是5 

整数比较测试

例如：`(( 10>2 ))` 判断10是否大于2

#### \[ \] 单方括号

通配符和正则中表示匹配括号中的任意一个字符

例如：`[abc]` 表示匹配abc中的任意一个字符

条件测试表达式

例如：`[ -f /etc/passwd ] // 测试是不是文件`

数组中下标括号 

例如：`echo ${a[0]}` 表示取数组中下标为0的值

#### \[\[ \]\] 双方括号

字符串比较测试

例如：`[[a=b]]` 用来字符串的比较

#### \. 英文句点号 

正则中表示任意1个字符

例如：`a...b` 表示 匹配 a和b之间夹三个字符的字符串

当前shell执行脚本命令

例如：`./test.sh` 执行当前路径下的shell脚本test.sh

表示当前目录

例如：`cd ./bgk` 进入当前目录下的bgk目录下

#### \{ \} 大括号

通配符扩展 `abc{1,2,3}` 

正则表达式中表示范围 

例如：`a{3}` 匹配3个 a

`for i in {1...10}` 循环指定范围 

匿名函数`{ cmd1；cmd2；cmd3；} &> /dev/null` ，

`{ }` 里面的命令，是在当前shell执行

注意：`{ }` 第一条命令前面要有空格，后面的命令要有分号

括起变量名 `${abc}a`

#### \/ 正斜杠

算术运算中的除法

例如：`echo $((10/2))` 结果就是5 

根目录或路径分割符

例如：`cd /usr/local/` 表示路径

#### \^ 上尖括号

在通配符中表示取反

例如：`[^abc]` 表示匹配除了abc外的任意一个字符

在正则表达式中表示以什么开头

例如：

`egrep ‘^hello$'  file`