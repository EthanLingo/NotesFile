tags: #内容/编程/Julia语言 
#知识 
tags: #来源/转载 



记住一点就行，Julia/Python的赋值语句产生新的对象。

> 参考[[Python函数传参方式]]

例：

```
a = [1,2,3]
b = a
# a = [1, 2, 3]
# b = [1, 2, 3]
# 此时a, b是同一个东西
a[1] = 2
# a = [2, 2, 3]
# b = [2, 2, 3]
# 此时a还是原来的a，只是被修改了（赋值语句作用的是a[1]不是a，a本身的对象不改变）
a = [4,3,2,1]
# a = [4, 3, 2, 1]
# b = [2, 2, 3]
# 此时 a= 为赋值语句，产生新的对象，旧对象仍然不变，只是失去了a这个名字
```

函数传参还是一个道理，只是函数因为作用域，里面新定义的量哪怕和外面重名也不影响外面，除非使用 `global`。

例：

```
a = [1,2,3]

function fun1(a)
    a = [3,2,1]
    # 此处赋值语句产生新的对象，函数里的a与送进来的
end

function fun2(a)
    a[1] = 3
    # 此处a仍然是送进来的a，函数外的将会改变
end
```

这种传参方式可能在将来的动态语言中会长期主流，因为习惯了之后最不容易犯错（比如大量复制传的参数消耗内存）。

另外，如果希望函数可以修改参数自身，使用 `Ref`，如：

```
a = Ref(1)

function change_a!(a::Ref{Int})
    a[] = 2
end

change_a!(a)

# a = Ref(2)
# a[] = 2
```



